1.자료구조 : 자료를 어떤 방식으로 구조화할 것인가를 정의 및 결정하는 요소
ex. 변수 // 배열

2.알고리즘 : 어떤 문제를 해결하기 위한 방법/솔루션
ex. 연산자 // 반복문

3.자료구조에 따라 알고리즘 바뀔 수도 있고, 사용하고자 하는 알고리즘에 따라 자료구조의 형태를 바꿔야할 수도 있다.

4.코드의 효율성 체크 방법 : 시간복잡도 개념 적용
- 빅오메가 (*어떤 문제를 해결하기 위한 알고리즘을 적용했을 때, 최고의 효율이 나는 경우에 한정 시간 측정)
- 빅세타 (*평균적인 시간 측정)
- 빅오 (*최악의 효율이 나는 경우 측정)
> 빅오의 개념을 항상 적용!!! why 외부의 물리적 변수에 최대한 영향을 받지 않는 환경에서 측정!!!

5.빅오의 시간복잡도 개념을 적용할 때 대원칙
- 연산처리의 세부적인 요소는 중요x
- 가장 시간을 많이 소비하는 요소를 기준으로 시간복잡도를 측정 => 반복문
- 이터러블한 객체 = 배열
- 어떤 경우 배열을 사용 VS 배열을 사용해서는 안되는 경우

6.연결리스트 VS 배열 비교
- 배열 : 참조타입 변수, 배열에 들어오는 첫번째 인덱스값만 찾으면 나머지 값들은 신속.정확하게 찾아올 수 있는 장점 // 전통적인 프로그래밍 언어들의 경우 배열 => 선언과 동시에 값을 픽스 & 사이즈를 저장 (*최초에 정의가 된 배열의 값을 수정.편집 비효율적인 작업)

- 연결리스트 : 메모리 공간에 산발적으로 흩어져있는 데이터를 모아서 연결해놓은 자료구조, 데이터의 편집.수정이 매우 효율적 // 연결리스트의 경우에는 산발적으로 흩어져있는 데이터 이기 때문에 배열보다 초기 로딩 속도가 늦다

7.연결리스트에서 자주 사용하는 기능 구현
- 추상자료형
- printAll( )
- indexAt( )
- clear( )
- insertLast( )
- deleteAt( )
- getNodeAt( )

8.Stack 연결리스트 내 자료구조 형태
- stack : 무언가를 쌓아올리다. 라는 사전적 의미
- 일상생활 : 설거지, 엘리베이터 탑승 등
- 입구 & 출구 동일 // 하나밖에 없음
- push( ) : 데이터를 삽입
- pop( ) : 데이터를 제거
- peek( ) : 데이터를 참조
- isEmpty( ) : 자료가 비었는지 여부 확인

9.Queue 연결리스트 내 자료구조 형태
- queue : 대기하다. & 기다리다 라는 사전적 의미
- 일상생활 : 커피점 & 식당 // 줄을 서서 기다리는 형태
- 입구 & 출구 각각 독립
- enqueue( ) : 데이터를 삽입
- dequeue( ) : 데이터를 제거
- front( ) : 데이터를 참조
- isEmpty( ) : 자료가 비었는지 여부 확인
> head & tail => 자료가 신규로 생성되는 위치 head 고정

10.Deque 연결리스트 내 자료구조 형태
- Queue와 형태는 동일 + 자료 생성 & 삭제 (*head & tail)
- printAll( ) : 모든 데이터를 출력
- addFirst( ) : head에 데이터를 삽입
- removeFirst( ) : headt에 데이터를 제거
- addLast( ) : tail에 데이터를 삽입
- removeLast( ) : tail에서 데이터를 제거
- isEmpty( ) : 해당 연결리스트의 자료.데이터가 비었는지 체크

11.HashTable 연결리스트 내 자료구조 형태
- hash : # => key
- table : 비효율적인 자료구조를 보다 효율적으로 관리하기 위한 목적으로 테이블의 형식을 참조하여 자료구조를 세팅하는 방법
- hash Function : "해시함수" 메모리 공간에 비효율적으로 자리잡고 있는 데이터를 효율적으로 보관.관리해주는 기능을 가지고 함수

내일 오전 : 자료구조!!!
> hashset

알고리즘
> 재귀 = recursion
- factorial
- 하노이 탑
- 병합정렬
- 버블정렬
- 퀵정렬
- 피보나치







